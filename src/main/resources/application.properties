# Se você não colocar nenhuma porta, ele assume que seja a padrao do Mysql(3306)
# O ? pra frente é opcional para colocarmos propriedades que quisermos
# Nesse caso colocamos a propriedade para criar o banco caso ele não exista.
# E também o de fuso horário padrão
spring.datasource.url=jdbc:mysql://localhost:3306/algafood?createDatabaseIfNotExist=true&serverTimezone=UTC
# usuário do banco
spring.datasource.username=root
# senha do banco
spring.datasource.password=admin

# Falando pro JPA gerar o DDL pra gente e executar ele no nosso banco de dados
# (Em desenvolvimento tudo bem fazer isso, mas em Produção não é boa prática)
# spring.jpa.generate-ddl=true

# (create
# Configuração especifica do hibernate, que estamos dizendo para a implementação do JPA a forma que o ddl vai ser executado
# Então o create dropa todas as tabelas e recria sempre que a aplicação reiniciar, como é um ambiente de teste aqui tudo bem por enquanto)

# (update
# Não vai dropar as tabelas, mas sim atualizar os dados na tabela, mas ainda não é uma boa prática, poe exemplo
# se formos alterar um nome de coluna no banco de dados, vai continuar a coluna anterior e adicionar uma NOVA coluna sem os dados
# da coluna anterior. Já se alterar o tipo ou alguma config da coluna, ele não altera, pois a coluna já existe.)

# Ou seja, nenhum é boa prática para utilizar em Produção.
# spring.jpa.hibernate.ddl-auto=update

# Remover depois de executado
# Pedindo pra ele gerar os scripts de geração de schema pra gente (Sem executar)
# spring.jpa.properties.javax.persistence.schema-generation.scripts.action=create

# Remover depois de executado
# Falando a localização que quer que ele crie os arquivos dos scripts que ele vai gerar
# spring.jpa.properties.javax.persistence.schema-generation.scripts.create-target=src/main/resources/ddl.sql

# Configuração onde podemos ver o JPQL gerado no console
# Também não é recomendado utilizar em ambiente de produção, somente em desenvolvimento
spring.jpa.show-sql=true

# Propriedade para gerar os sql de criação de tabela com o motor INNODB e permitir chaves estrangeiras
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# Falando pro hikari qual o máximo de conexões que queremos no pool de conexões com o database (Padrão é 10)
spring.datasource.hikari.maximum-pool-size=5
# No mínimo 3 (Padrão é 10), e inclusive, quando colocamos 5 na config de máximo, ele configura por padrao o numero do máximo no mínimo caso não colocamos nada.
spring.datasource.hikari.minimum-idle=3
# Tempo até o pool matar as conexões excedentes do máximo (Tempo limite de ociosidade) em milissegundos. (O mínimo que vc pode colcoar é 10s)
# Detalhe que isso não é um número preciso, serve mais como uma SUGESTÃO que damos ao hikari para encerrar nesse tempo.
# Basicamente aqui falamos "a partir de 10 segundos de ociosidade, quando você for checar sua rotina pra matar, pode matar"
spring.datasource.hikari.connection-timeout=10000

# Propriedade onde especificamos onde o flyway vai encontrar os scripts de migração e de callback
# Falamos então: classpath (busque dentro da nossa própria aplicação) (src/main)
# Então indicamos duas pastas que ele deve buscar, então vai executar as coisas das duas pastas.
# E fazemos isso, pois adicionamos um profile de dev e um de prd, e então podemos separar o arquivo testdata
# de teste e de produção, fazendo ele usar o testdata somente em ambiente de test, em prd isso nem existe.
spring.flyway.locations=classpath:db/migration,classpath:db/testdata

# (ResponseStatus, ResponseStatusException)
# A partir da versão 2.3 do Spring boot não está incluido nas respostas a mensagem de erro e sim somente o retorno de
# erro padrão (sem mensagem), fizeram isso para reduzir o risco de vazar informações delicadas,
# para colocar mensagem de erro inclua nas properties:
server.error.include-message=ALWAYS

# Propriedade para habilitar lançamento de exception para quando propriedade passada no Json da requisição não exista
# default é false
spring.jackson.deserialization.fail-on-unknown-properties=true

# Propriedade para habilitar lançamento de exception para quando a propriedade no objeto está com @JsonIgnore
spring.jackson.deserialization.fail-on-ignored-properties=true

# Ativando funcionalidade para lançar o no handler found
spring.mvc.throw-exception-if-no-handler-found=true

# Desabilitando o cara que serve arquivos estáticos dentro de resources (static)
spring.web.resources.add-mappings=false
